/**
 * CoolScanner.java
 * 
 * This is a scanner generated by JFlex
 * for the COOL programming language.
 * 
 * @author: Paul Elliott
 * @date: 4/11/13
 */

package main;

import beaver.Symbol;
import beaver.Scanner;

%%

%class CoolScanner
%extends Scanner
%unicode
%function nextToken
%type Symbol
%yylexthrow Scanner.Exception
%eofval{
    return token(Terminals.EOF, "end-of-file");
%eofval}
%line
%column

%{
    StringBuffer string = new StringBuffer(128);

    private Symbol token(short id)
    {
        return new Symbol(id, yyline + 1, yycolumn + 1, yylength(), yytext());
    }
    
    private Symbol token(short id, Object value)
    {
        return new Symbol(id, yyline + 1, yycolumn + 1, yylength(), value);
    }
%}

/* macros */
LineTerminator = \r|\n|\r\n
InputChar = [^\r\n]
Comment = {EndOfLineComment}

EndOfLineComment = "//" {InputChar}* {LineTerminator}?
TraditionalCommentBegin = "/*"
TraditionalCommentEnd = "*/"

WhiteSpace = {LineTerminator} | [ \t\f]

Integer = 0 | [1-9][0-9]*

TypeIdentifier = [A-Z][:jletterdigit:]*
ObjectIdentifier = [a-z][:jletterdigit:]*

ThreeQuote = \"\"\"
SingleQuote = \"

StringChar = [^\r\n\"\\]
MultiStringChar = [^\"]
EscapeChar = "\\0" | "\\b" | "\\t" | "\\n" | "\\r" | "\\f" | "\\\"" | "\\\\"


IllegalKeywords = (abstract|catch|do|final|finally|for|forSome|implicit|import|lazy|object|package|private|protected|requires|return|sealed|throw|trait|try|type|val|with|yield)

%state STRING, MULTISTRING, TRADITIONALCOMMENT

%%

/* definitions */
<YYINITIAL> {
    {IllegalKeywords}   { new ErrorReport(yyline + 1, yycolumn + 1, "Illegal keyword", yytext()); }
    {Comment}           { /* ignore */ }
    {TraditionalCommentBegin} { yybegin(TRADITIONALCOMMENT); }
    {WhiteSpace}        { /* ignore */ }

    "("                 { return token(Terminals.LPAREN); }
    "{"                 { return token(Terminals.LBRACE); }
    "null"              { return token(Terminals.NULL); }
    "super"             { return token(Terminals.SUPER); }
    "new"               { return token(Terminals.NEW); }
    "this"              { return token(Terminals.THIS); }
    "if"                { return token(Terminals.IF); }
    "while"             { return token(Terminals.WHILE); }
    "!"                 { return token(Terminals.NOT); }
    ")"                 { return token(Terminals.RPAREN); }
    ":"                 { return token(Terminals.COLON); }
    "var"               { return token(Terminals.VAR); }
    "}"                 { return token(Terminals.RBRACE); }
    ";"                 { return token(Terminals.SEMI); }
    "="                 { return token(Terminals.ASSIGN); }
    "case"              { return token(Terminals.CASE); }
    "def"               { return token(Terminals.DEF); }
    "native"            { return token(Terminals.NATIVE); }
    ","                 { return token(Terminals.COMMA); }
    "=>"                { return token(Terminals.ARROW); }
    "."                 { return token(Terminals.DOT); }
    "class"             { return token(Terminals.CLASS); }
    "else"              { return token(Terminals.ELSE); }
    "extends"           { return token(Terminals.EXTENDS); }
    "override"          { return token(Terminals.OVERRIDE); }
    "<="                { return token(Terminals.LE); }
    "<"                 { return token(Terminals.LT); }
    "=="                { return token(Terminals.EQUALS); }
    "*"                 { return token(Terminals.TIMES); }
    "/"                 { return token(Terminals.DIV); }
    "+"                 { return token(Terminals.PLUS); }
    "-"                 { return token(Terminals.MINUS); }
    "match"             { return token(Terminals.MATCH); }
    "true"              { return token(Terminals.BOOLEAN); }
    "false"             { return token(Terminals.BOOLEAN); }

    {Integer}           { return token(Terminals.INTEGER); }
    {ObjectIdentifier}  { return token(Terminals.ID); }
    {TypeIdentifier}    { return token(Terminals.TYPE); }

    {SingleQuote}       { yybegin(STRING); string.setLength(0); }
    {ThreeQuote}        { yybegin(MULTISTRING); string.setLength(0); }
    .                   { new ErrorReport(yyline + 1, yycolumn + 1, "Unknown symbol     found.", yytext()); }
}

<STRING> {
    \"                  { yybegin(YYINITIAL); return token(Terminals.STRING, string.toString()); }
    
    {StringChar}+       { string.append( yytext() ); }

    "\\0"               { string.append( '\0' ); }
    "\\b"               { string.append( '\b' ); }
    "\\t"               { string.append( '\t' ); }
    "\\n"               { string.append( '\n' ); }
    "\\r"               { string.append( '\r' ); }
    "\\f"               { string.append( '\f' ); }
    "\\\""              { string.append( '\"' ); }
    "\\\\"              { string.append( '\\' ); }

    \\.                 { yybegin(YYINITIAL); new ErrorReport(yyline + 1, yycolumn + 1, "Illegal escape sequence \""+yytext()+"\"", string.toString()); }
    {LineTerminator}    { yybegin(YYINITIAL); new ErrorReport(yyline + 1, yycolumn + 1, "Unterminated string at end of line", string.toString()); }
    <<EOF>>             { yybegin(YYINITIAL); new ErrorReport(yyline + 1, yycolumn     + 1, "Unterminated string at end of file", string.toString()); }
}   

<MULTISTRING> {
    {ThreeQuote}        { yybegin(YYINITIAL); return token(Terminals.STRING, string.toString()); }
    {SingleQuote}       { string.append( yytext() ); }
    {MultiStringChar}+  { string.append( yytext() ); }
    <<EOF>>             { yybegin(YYINITIAL); new ErrorReport(yyline + 1, yycolumn     + 1, "Unterminated string at end of file", string.toString()); }
}

<TRADITIONALCOMMENT> {
    .                   { /* do nothing */ }
    {EscapeChar} | {InputChar} | {LineTerminator}        { /* do nothing */ }
    <<EOF>>             { yybegin(YYINITIAL); new ErrorReport(yyline + 1, yycolumn + 1, "Comment ended by end of file", ""); }

    {TraditionalCommentEnd} { yybegin(YYINITIAL); }
}
